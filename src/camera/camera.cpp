/** @file camera.cpp
 *  @brief Contains methods for the Camera class.
 *  @copyright BSD-3-Clause License
 */

#include <iostream>
#include <flycapture/Error.h>
#include "camera.h"

// Declaration of static variables
FlyCapture2::BusManager Camera::_bus_manager;

Camera::Camera()
{
    // Making sure the OpenCV Mat isn't empty
    _last_frame = cv::Mat(1, 1, CV_8UC1, 255);
}

Camera::~Camera()
{
    disconnect();
}

/**
 * @brief Returns the number of cameras physically connected to the computer.
 * @return Number of cameras available, 0 if an error occures
 */
unsigned int Camera::get_num_available_cameras()
{
    FlyCapture2::Error err;
    unsigned int num_cameras;

    err = _bus_manager.GetNumOfCameras(&num_cameras);
    if(err != FlyCapture2::PGRERROR_OK) {
        err.PrintErrorTrace();
        num_cameras = 0;
    }

    return num_cameras;
}

/**
 * @brief Recovers the FlyCapture2::PGRGuid related to the index. First camera starts at 0 and increment for each available camera.
 * @param [in] index: Index of the camera (should not exceed the number of available cameras)
 * @param [out] guid: Address of the FlyCapture2::PGRGuid of the camera
 * @return Error code FlyCapture2::Error (0 = No errors)
 */
int Camera::get_guid(unsigned int index, FlyCapture2::PGRGuid *guid)
{
    FlyCapture2::Error err;

    err = _bus_manager.GetCameraFromIndex(index, guid);

    if(err != FlyCapture2::PGRERROR_OK) {
        err.PrintErrorTrace();
    }

    return err.GetType();
}

/**
 * @brief Connect to a camera.
 * @param guid: GUID of the camera (see Camera::get_guid)
 * @bug PC (Ubuntu) sometimes freezes when disconnecting/connecting multiple times in quick succession.
 * Workaround: Unplug and plug back the USB cable before calling Camera::connect again.
 * @return Error code FlyCapture2::Error (0 = No errors)
 */
int Camera::connect(FlyCapture2::PGRGuid *guid)
{
    FlyCapture2::Error err;

    // Connect camera
    err = this->Connect(guid);

    // Print error if any
    if(err != FlyCapture2::PGRERROR_OK) {
        err.PrintErrorTrace();
    }

    return err.GetType();
}

/**
 * @brief Disconnect from the camera.
 * @return Error code FlyCapture2::Error (0 = No errors)
 */
int Camera::disconnect()
{
    FlyCapture2::Error err;

    // Stop capture
    if(_is_capturing) {
        stop_capture();
    }

    // Disconnect
    err = Disconnect();

    // Print error if any
    if(err != FlyCapture2::PGRERROR_OK) {
        err.PrintErrorTrace();
    }

    return err.GetType();
}

/**
 * @brief Get the camera's serial number.
 * @return Serial number as an integer (0 = Error)
 */
unsigned int Camera::get_serial_number()
{
    FlyCapture2::CameraInfo camera_info;

    // Retrieve Format7 info from camera
    if(_get_camera_info(&camera_info) != FlyCapture2::PGRERROR_OK) {
        return 0;
    }

    // Return height
    return camera_info.serialNumber;
}

/**
 * @brief Get the camera's image height in pixels.
 * @return Height of the image generated by the camera (0 = Error)
 */
unsigned int Camera::get_camera_height()
{
    // If we already acquired the camera height, don't ask the camera a second time
    if(_camera_height == 0) {
        // Ask the camera its image height
        FlyCapture2::Format7Info f7_info;

        // Retrieve Format7 info from camera
        if(_get_format7_info(&f7_info) != FlyCapture2::PGRERROR_OK) {
            return 0;
        }

        // Save image height
        _camera_height = f7_info.maxHeight;
    }

    return _camera_height;
}

/**
 * @brief Get the camera's image width in pixels.
 * @return Width of the image generated by the camera (0 = Error)
 */
unsigned int Camera::get_camera_width()
{
    // If we already acquired the camera width, don't ask the camera a second time
    if(_camera_width == 0) {
        FlyCapture2::Format7Info f7_info;

        // Retrieve Format7 info from camera
        if(_get_format7_info(&f7_info) != FlyCapture2::PGRERROR_OK) {
            return 0;
        }

        // Save image width
        _camera_width = f7_info.maxWidth;
    }

    return _camera_width;
}

/**
 * @brief Configure a camera
 * @param f7_image_settings: See FlyCapture2::Format7ImageSettings, or leave empty (nullptr) for default
 * @param flycapture_config: See FlyCapture2::FC2Config, or leave empty (nullptr) for default
 * @return Error code FlyCapture2::Error (0 = No errors)
 */
int Camera::configure(FlyCapture2::Format7ImageSettings *f7_image_settings, FlyCapture2::FC2Config *flycapture_config)
{
    FlyCapture2::Error err;
    FlyCapture2::Format7ImageSettings _f7_image_settings;
    FlyCapture2::FC2Config _flycapture_config;

    // Look if Format7 Image Settings were provided, otherwise initialize with default values
    if(f7_image_settings == nullptr) {
        _f7_image_settings.mode = FlyCapture2::MODE_0;
        _f7_image_settings.height = get_camera_height();
        _f7_image_settings.width = get_camera_width();
        _f7_image_settings.offsetX = 0;
        _f7_image_settings.offsetY = 0;
        _f7_image_settings.pixelFormat = FlyCapture2::PIXEL_FORMAT_RAW8;    // Global shutter = RAW8; Rolling shutter = MONO8
    }
    else
        _f7_image_settings = *f7_image_settings;

    // Send Format7 Image Settings to the camera
    err = SetFormat7Configuration(&_f7_image_settings, (float)100.0);
    if(err != FlyCapture2::PGRERROR_OK) {
        std::cout << "Can't set Format7 Image Settings." << std::endl;
        err.PrintErrorTrace();
        return err.GetType();
    }

    // Look if FlyCapture Configurations were provided, otherwise initialize with default values
    if(flycapture_config == nullptr) {
        _flycapture_config.numBuffers = 1;
        _flycapture_config.numImageNotifications = 1;
        _flycapture_config.grabTimeout = FlyCapture2::TIMEOUT_NONE;
        _flycapture_config.grabMode = FlyCapture2::GrabMode::DROP_FRAMES;
        _flycapture_config.highPerformanceRetrieveBuffer = true;
        _flycapture_config.isochBusSpeed = FlyCapture2::BusSpeed::BUSSPEED_S5000;
        _flycapture_config.asyncBusSpeed = FlyCapture2::BusSpeed::BUSSPEED_ANY;
        _flycapture_config.bandwidthAllocation = FlyCapture2::BandwidthAllocation::BANDWIDTH_ALLOCATION_UNSPECIFIED;
        _flycapture_config.registerTimeoutRetries = 0;
        _flycapture_config.registerTimeout = 0;
    }
    else
        _flycapture_config = *flycapture_config;

    // Send FlyCapture Configurations to the camera
    err = SetConfiguration(&_flycapture_config);
    if(err != FlyCapture2::PGRERROR_OK) {
        std::cout << "Can't set FlyCapture Configurations." << std::endl;
        err.PrintErrorTrace();
    }

    return err.GetType();
}

/**
 * @brief Set a FlyCapture property in the camera.
 * @param property: Pointer of the FlyCapture2::Property to be sent to the camera
 * @param throw_exception: This parameter determines if this function will throw an exception if something goes wrong
 * (see Camera::ExceptionHandling)
 * @return Error code FlyCapture2::Error (0 = No errors)
 */
int Camera::set_property(FlyCapture2::Property *property, ExceptionHandling throw_exception)
{
    FlyCapture2::Error err;

    err = SetProperty(property);
    if(err != FlyCapture2::PGRERROR_OK) {
        std::cout << "Error setting property: " << property->type << std::endl;
        err.PrintErrorTrace();
        if(throw_exception == ExceptionHandling::ThrowExceptions)
            throw err.GetType();
    }

    return err.GetType();
}

/**
 * @brief Get a FlyCapture property from the camera.
 * @param property_type: FlyCapture2::PropertyType of the property to retrive
 * @param property Pointer: to an empty FlyCapture2::Property variable
 * @param throw_exception: This parameter determines if this function will throw an exception if something goes wrong
 * (see Camera::ExceptionHandling)
 * @return Error code FlyCapture2::Error (0 = No errors)
 */
int Camera::get_property(FlyCapture2::PropertyType property_type, FlyCapture2::Property *property, ExceptionHandling throw_exception)
{
    FlyCapture2::Error err;
    property->type = property_type;

    err = GetProperty(property);
    if(err != FlyCapture2::PGRERROR_OK) {
        std::cout << "Error retrieving property: " << property_type << std::endl;
        err.PrintErrorTrace();
        if(throw_exception == ExceptionHandling::ThrowExceptions)
            throw err.GetType();
    }

    return err.GetType();
}

/**
 * @brief Set the FlyCapture Trigger Mode in the camera
 * @param trigger_mode: Pointer of the FlyCapture2::TriggerMode to be sent to the camera
 * @param throw_exception: This parameter determines if this function will throw an exception if something goes wrong
 * (see Camera::ExceptionHandling)
 * @return Error code FlyCapture2::Error (0 = No errors)
 */
int Camera::set_trigger_mode(FlyCapture2::TriggerMode *trigger_mode, ExceptionHandling throw_exception)
{
    FlyCapture2::Error err;

    err = SetTriggerMode(trigger_mode);
    if(err != FlyCapture2::PGRERROR_OK) {
        std::cout << "Error setting Trigger Mode" << std::endl;
        err.PrintErrorTrace();
        if(throw_exception == ExceptionHandling::ThrowExceptions)
            throw err.GetType();
    }

    return err.GetType();
}

/**
 * @brief Get the FlyCapture Trigger Mode from the camera.
 * @param trigger_mode: Pointer to an empty FlyCapture2::TriggerMode variable
 * @param throw_exception: This parameter determines if this function will throw an exception if something goes wrong
 * (see Camera::ExceptionHandling)
 * @return Error code FlyCapture2::Error (0 = No errors)
 */
int Camera::get_trigger_mode(FlyCapture2::TriggerMode *trigger_mode, ExceptionHandling throw_exception)
{
    FlyCapture2::Error err;

    err = GetTriggerMode(trigger_mode);
    if(err != FlyCapture2::PGRERROR_OK) {
        std::cout << "Error retrieving Trigger Mode" << std::endl;
        err.PrintErrorTrace();
        if(throw_exception == ExceptionHandling::ThrowExceptions)
            throw err.GetType();
    }

    return err.GetType();
}

/**
 * @brief Set the FlyCapture Strobe Control in the camera
 * @param strobe_control: Pointer of the FlyCapture2::StrobeControl to be sent to the camera
 * @param throw_exception: This parameter determines if this function will throw an exception if something goes wrong
 * (see Camera::ExceptionHandling)
 * @return Error code FlyCapture2::Error (0 = No errors)
 */
int Camera::set_strobe_control(FlyCapture2::StrobeControl *strobe_control, ExceptionHandling throw_exception)
{
    FlyCapture2::Error err;

    err = SetStrobe(strobe_control);
    if(err != FlyCapture2::PGRERROR_OK) {
        std::cout << "Error setting Strobe Control" << std::endl;
        err.PrintErrorTrace();
        if(throw_exception == ExceptionHandling::ThrowExceptions)
            throw err.GetType();
    }

    return err.GetType();
}

/**
 * @brief Get the FlyCapture Strobe Control from the camera.
 * @param strobe_control: Pointer to an empty FlyCapture2::StrobeControl variable
 * @param throw_exception: This parameter determines if this function will throw an exception if something goes wrong
 * (see Camera::ExceptionHandling)
 * @return Error code FlyCapture2::Error (0 = No errors)
 */
int Camera::get_strobe_control(FlyCapture2::StrobeControl *strobe_control, ExceptionHandling throw_exception)
{
    FlyCapture2::Error err;

    err = GetStrobe(strobe_control);
    if(err != FlyCapture2::PGRERROR_OK) {
        std::cout << "Error retrieving Strobe Control" << std::endl;
        err.PrintErrorTrace();
        if(throw_exception == ExceptionHandling::ThrowExceptions)
            throw err.GetType();
    }

    return err.GetType();
}

/**
 * @brief Set a callback that will be called every time a new frame is received from the camera
 * @param callback: Pointer to the callback function
 * @param callback_data: Pointer to the data that will be passed with every callback calls
 */
void Camera::set_new_frame_callback(std::function<void(cv::Mat*, void*)> callback, void *callback_data)
{
    _new_frame_external_callback = std::bind(callback, std::placeholders::_1, std::placeholders::_2);
    _external_callback_data = callback_data;
}

/**
 * @brief Start capturing images
 * @return Error code FlyCapture2::Error (0 = No errors)
 */
int Camera::start_capture()
{
    FlyCapture2::Error err;

    // Exit if already capturing
    if(_is_capturing)
        return FlyCapture2::PGRERROR_OK;

    _is_capturing = true;
    err = StartCapture(_new_frame_internal_callback, this);
    if(err != FlyCapture2::PGRERROR_OK) {
        std::cout << "Error starting capture" << std::endl;
        err.PrintErrorTrace();
        _is_capturing = false;
    }

    return err.GetType();
}

/**
 * @brief Stop capturing
 * @return Error code FlyCapture2::Error (0 = No errors)
 */
int Camera::stop_capture()
{
    FlyCapture2::Error err;

    // Exit if not capturing
    if(!_is_capturing)
        return FlyCapture2::PGRERROR_OK;

    _is_capturing = false;
    err = StopCapture();
    if(err != FlyCapture2::PGRERROR_OK) {
        std::cout << "Error stopping capture" << std::endl;
        err.PrintErrorTrace();
        _is_capturing = true;
    }

    return err.GetType();
}

/**
 * @brief Utility function that sets all properties for the CoRo Eyes camera.
 * @param camera_position: Position of the camera (see Camera::CameraPosition)
 * @return Error code FlyCapture2::Error (0 = No errors)
 */
int Camera::set_properties_for_coro_eyes(CameraPosition camera_position)
{
    FlyCapture2::Property property;
    FlyCapture2::TriggerMode trigger_mode;
    FlyCapture2::StrobeControl strobe_control;

    // Exit if camera position is undefined
    if(camera_position == CameraPosition::Undefined)
        return FlyCapture2::PGRERROR_UNDEFINED;

    // Set all properties
    try {
        // Brightness
        get_property(FlyCapture2::PropertyType::BRIGHTNESS, &property, ExceptionHandling::ThrowExceptions);
        property.valueA = 0.0;
        set_property(&property, ExceptionHandling::ThrowExceptions);

        // Auto-exposure
        get_property(FlyCapture2::PropertyType::AUTO_EXPOSURE, &property, ExceptionHandling::ThrowExceptions);
        property.onOff = false;
        property.absValue = 1.0;
        set_property(&property, ExceptionHandling::ThrowExceptions);

        // Sharpness
        get_property(FlyCapture2::PropertyType::SHARPNESS, &property, ExceptionHandling::ThrowExceptions);
        property.valueA = 1024;
        set_property(&property, ExceptionHandling::ThrowExceptions);

        // Gamma
        get_property(FlyCapture2::PropertyType::GAMMA, &property, ExceptionHandling::ThrowExceptions);
        property.absValue = 1.0;
        set_property(&property, ExceptionHandling::ThrowExceptions);

        // Shutter
        get_property(FlyCapture2::PropertyType::SHUTTER, &property, ExceptionHandling::ThrowExceptions);
        property.absValue = 2.0;
        set_property(&property, ExceptionHandling::ThrowExceptions);

        // Gain
        get_property(FlyCapture2::PropertyType::GAIN, &property, ExceptionHandling::ThrowExceptions);
        property.absValue = 0.0;
        set_property(&property, ExceptionHandling::ThrowExceptions);

        // Frame rate
        get_property(FlyCapture2::PropertyType::FRAME_RATE, &property, ExceptionHandling::ThrowExceptions);
        property.absValue = 60.0;
        set_property(&property, ExceptionHandling::ThrowExceptions);

        // Trigger delay
        get_property(FlyCapture2::PropertyType::TRIGGER_DELAY, &property, ExceptionHandling::ThrowExceptions);
        property.absValue = 0.0;
        set_property(&property, ExceptionHandling::ThrowExceptions);

        // Trigger mode
        get_trigger_mode(&trigger_mode, ExceptionHandling::ThrowExceptions);
        trigger_mode.onOff = (camera_position == CameraPosition::Right);    // The right camera receives an external trigger
        trigger_mode.polarity = 1;
        trigger_mode.source = 3;
        trigger_mode.mode = 0;
        trigger_mode.parameter = 0;
        set_trigger_mode(&trigger_mode, ExceptionHandling::ThrowExceptions);

        // Strobe mode
        strobe_control.source = 2;  // The Strobe Source must be set before calling get or set
        get_strobe_control(&strobe_control, ExceptionHandling::ThrowExceptions);
        strobe_control.onOff = (camera_position == CameraPosition::Left);    // The left camera generates the trigger
        strobe_control.polarity = 0;
        strobe_control.delay = 0;
        strobe_control.duration = 1.0;
        set_strobe_control(&strobe_control, ExceptionHandling::ThrowExceptions);
    }
    catch(FlyCapture2::ErrorType err) {
        std::cout << "Something went wrong. Aborting..." << std::endl;
        return err;
    }

    return FlyCapture2::PGRERROR_OK;
}

/**
 * @brief Retrieve Format7 info from the camera.
 * @param [out] f7_info: Pointer to the Format7 Info variable
 * @return Error code FlyCapture2::Error (0 = No errors)
 */
int Camera::_get_format7_info(FlyCapture2::Format7Info *f7_info)
{
    FlyCapture2::Error err;
    bool f7_supported = false;

    // Retrieve Format7 info from camera
    err = GetFormat7Info(f7_info, &f7_supported);
    if(err != FlyCapture2::PGRERROR_OK || !f7_supported) {
        f7_info = nullptr;
        std::cout << "Can't retrieve Format7 info." << std::endl;
        err.PrintErrorTrace();
    }

    return err.GetType();
}

/**
 * @brief Retrieve Camera Info.
 * @param [out] camera_info: Pointer to the Camera Info variable
 * @return Error code FlyCapture2::Error (0 = No errors)
 */
int Camera::_get_camera_info(FlyCapture2::CameraInfo *camera_info)
{
    FlyCapture2::Error err;

    // Retrieve Format7 info from camera
    err = GetCameraInfo(camera_info);
    if(err != FlyCapture2::PGRERROR_OK) {
        camera_info = nullptr;
        std::cout << "Can't retrieve Camera Info." << std::endl;
        err.PrintErrorTrace();
    }

    return err.GetType();
}

/**
 * @brief Internal callback to make a copy of each new frame received.
 * @details Only the last frame will be kept within the class.
 */
void Camera::_new_frame_internal_callback(FlyCapture2::Image *frame, const void *callback_data)
{
    Camera *camera = (Camera*)callback_data;

    // Create an OpenCV image from the FlyCapture2::Image
    cv::Mat cv_frame(camera->get_camera_height(), camera->get_camera_width(), CV_8UC1, frame->GetData());

    // Make a deep copy of the Openc CV image
    camera->_last_frame = cv_frame.clone();

    // Call external callback if it has been set
    if(camera->_new_frame_external_callback)
        camera->_new_frame_external_callback(&camera->_last_frame, camera->_external_callback_data);
}
